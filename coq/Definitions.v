(*******************************************************************************
*                                                                              *
*   Definitions.v                                                              *
*   Xuejing Huang 2021                                                         *
*   Distributed under the terms of the GPL-v3 license                          *
*                                                                              *
*   This file is part of DistributingTypes.                                    *
*                                                                              *
*   DistributingTypes is free software: you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by       *
*   the Free Software Foundation, either version 3 of the License, or          *
*   (at your option) any later version.                                        *
*                                                                              *
*   DistributingTypes is distributed in the hope that it will be useful,       *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of             *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
*   GNU General Public License for more details.                               *
*                                                                              *
*   You should have received a copy of the GNU General Public License          *
*   along with DistributingTypes.  If not, see <https://www.gnu.org/licenses/>.*
*                                                                              *
*******************************************************************************)

(* generated by Ott 0.31 from: ../spec/rules.ott *)
(* some comments are added manually *)


Require Import Arith.
Require Import Bool.
Require Import List.


(***************************************************************)
(** definitions of syntax and auxiliary functions **)

(* This is Type defined at the beginning of Sec 3.1 *)
Inductive typ : Set :=  (* types *)
 | t_int : typ (* int *)
 | t_top : typ (* top type *)
 | t_bot : typ (* bottom type *)
 | t_arrow (A:typ) (B:typ) (* function type *)
 | t_and (A:typ) (B:typ) (* intersection *)
 | t_or (A:typ) (B:typ) (* union *).

(* This is Mode defined at the beginning of Sec 4.1 *)
Inductive mode : Set :=
 | m_sub : mode (* subtyping *)
 | m_super : mode (* supertyping *).

(* These three functions are defined at the top of Fig. 7 *)
Definition typbymode (m: mode) :=
  match m with
  | m_sub => t_top
  | m_super => t_bot
  end.

Definition choose (m: mode) (A: typ) (B: typ) :=
  match m with
  | m_sub => t_and A B
  | m_super => t_or A B
  end.

Definition flipmode (m: mode) :=
  match m with
  | m_sub => m_super
  | m_super => m_sub
  end.


(***************************************************************)
(** definitions of subtyping / duotyping relations **)

(* This is declarative subtyping defined in Fig. 4 *)
Inductive declarative_subtyping : typ -> typ -> Prop :=
 | DS_refl : forall (A:typ),
     declarative_subtyping A A
 | DS_trans : forall (A C B:typ),
     declarative_subtyping A B ->
     declarative_subtyping B C ->
     declarative_subtyping A C
 | DS_top : forall (A:typ),
     declarative_subtyping A t_top
 | DS_bot : forall (A:typ),
     declarative_subtyping t_bot A
 | DS_arrow : forall (A C B D:typ),
     declarative_subtyping B A ->
     declarative_subtyping C D ->
     declarative_subtyping (t_arrow A C) (t_arrow B D)
 | DS_and : forall (A B C:typ),
     declarative_subtyping A B ->
     declarative_subtyping A C ->
     declarative_subtyping A (t_and B C)
 | DS_andl : forall (A B:typ),
     declarative_subtyping (t_and A B) A
 | DS_andr : forall (A B:typ),
     declarative_subtyping (t_and A B) B
 | DS_or : forall (A B C:typ),
     declarative_subtyping A C ->
     declarative_subtyping B C ->
     declarative_subtyping (t_or A B) C
 | DS_orl : forall (A B:typ),
     declarative_subtyping A (t_or A B)
 | DS_orr : forall (B A:typ),
     declarative_subtyping B (t_or A B)
 | DS_distArr : forall (A B1 B2:typ),
     declarative_subtyping (t_and  (t_arrow A B1)   (t_arrow A B2) ) (t_arrow A (t_and B1 B2))
 | DS_distArrRev : forall (A B1 B2:typ),
     declarative_subtyping (t_arrow A (t_and B1 B2)) (t_and  (t_arrow A B1)   (t_arrow A B2) )
 | DS_distArrU : forall (A1 B A2:typ),
     declarative_subtyping (t_and  (t_arrow A1 B)   (t_arrow A2 B) ) (t_arrow (t_or A1 A2) B)
 | DS_distArrURev : forall (A1 A2 B:typ),
     declarative_subtyping (t_arrow (t_or A1 A2) B) (t_and  (t_arrow A1 B)   (t_arrow A2 B) )
 | DS_distOr : forall (A1 B A2:typ),
     declarative_subtyping (t_and  (t_or A1 B)   (t_or A2 B) ) (t_or  (t_and A1 A2)  B)
 | DS_distAnd : forall (A1 A2 B:typ),
     declarative_subtyping (t_and  (t_or A1 A2)  B) (t_or  (t_and A1 B)   (t_and A2 B) ).

(* This is declarative subtyping defined in Fig. 4 minus DS_distAnd *)
(* It is only used in DistAnd.v *)
Inductive declarative_subtyping_distor : typ -> typ -> Prop :=
 | DSO_refl : forall (A:typ),
     declarative_subtyping_distor A A
 | DSO_trans : forall (A C B:typ),
     declarative_subtyping_distor A B ->
     declarative_subtyping_distor B C ->
     declarative_subtyping_distor A C
 | DSO_top : forall (A:typ),
     declarative_subtyping_distor A t_top
 | DSO_bot : forall (A:typ),
     declarative_subtyping_distor t_bot A
 | DSO_arrow : forall (A C B D:typ),
     declarative_subtyping_distor B A ->
     declarative_subtyping_distor C D ->
     declarative_subtyping_distor (t_arrow A C) (t_arrow B D)
 | DSO_and : forall (A B C:typ),
     declarative_subtyping_distor A B ->
     declarative_subtyping_distor A C ->
     declarative_subtyping_distor A (t_and B C)
 | DSO_andl : forall (A B:typ),
     declarative_subtyping_distor (t_and A B) A
 | DSO_andr : forall (A B:typ),
     declarative_subtyping_distor (t_and A B) B
 | DSO_or : forall (A B C:typ),
     declarative_subtyping_distor A C ->
     declarative_subtyping_distor B C ->
     declarative_subtyping_distor (t_or A B) C
 | DSO_orl : forall (A B:typ),
     declarative_subtyping_distor A (t_or A B)
 | DSO_orr : forall (B A:typ),
     declarative_subtyping_distor B (t_or A B)
 | DSO_distArr : forall (A B1 B2:typ),
     declarative_subtyping_distor (t_and  (t_arrow A B1)   (t_arrow A B2) ) (t_arrow A (t_and B1 B2))
 | DSO_distArrRev : forall (A B1 B2:typ),
     declarative_subtyping_distor (t_arrow A (t_and B1 B2)) (t_and  (t_arrow A B1)   (t_arrow A B2) )
 | DSO_distArrU : forall (A1 B A2:typ),
     declarative_subtyping_distor (t_and  (t_arrow A1 B)   (t_arrow A2 B) ) (t_arrow (t_or A1 A2) B)
 | DSO_distArrURev : forall (A1 A2 B:typ),
     declarative_subtyping_distor (t_arrow (t_or A1 A2) B) (t_and  (t_arrow A1 B)   (t_arrow A2 B) )
 | DSO_distOr : forall (A1 B A2:typ),
     declarative_subtyping_distor (t_and  (t_or A1 B)   (t_or A2 B) ) (t_or  (t_and A1 A2)  B).

(* This is disjunctive ordinary types defined in Fig. 5 *)
Inductive single_ord : typ -> Prop :=    (* w.r.t intersection types *)
 | SO_top :
     single_ord t_top
 | SO_bot :
     single_ord t_bot
 | SO_int :
     single_ord t_int
 | SO_arrow : forall (A B:typ),
     ordu A ->
     single_ord B ->
     single_ord (t_arrow A B)
 | SO_or : forall (A B:typ),
     single_ord A ->
     single_ord B ->
     single_ord (t_or A B)
(* This is conjunctive ordinary types defined in Fig. 5 *)
with ordu : typ -> Prop :=    (* w.r.t union types *)
 | OU_top :
     ordu t_top
 | OU_bot :
     ordu t_bot
 | OU_int :
     ordu t_int
 | OU_arrow : forall (A B:typ),
     ordu (t_arrow A B)
 | OU_and : forall (A B:typ),
     ordu A ->
     ordu B ->
     ordu (t_and A B).

(* This is disjunctive splittable types defined in Fig. 5 *)
Inductive single_spl : typ -> typ -> typ -> Prop:=(* w.r.t intersection types *)
 | SSp_and : forall (A B:typ),
     single_spl (t_and A B) A B
 | SSp_arrow : forall (A B C D:typ),
     single_spl B C D ->
     single_spl (t_arrow A B) (t_arrow A C) (t_arrow A D)
 | SSp_arrowUnion : forall (A D B C:typ),
     single_ord D ->
     splu A B C ->
     single_spl (t_arrow A D) (t_arrow B D) (t_arrow C D)
 | SSp_orl : forall (A B A1 A2:typ),
     single_spl A A1 A2 ->
     single_spl (t_or A B) (t_or A1 B) (t_or A2 B)
 | SSp_orr : forall (A B B1 B2:typ),
     single_ord A ->
     single_spl B B1 B2 ->
     single_spl (t_or A B) (t_or A B1) (t_or A B2)
(* This is conjunctive splittable types defined in Fig. 5 *)
with splu : typ -> typ -> typ -> Prop :=  (* w.r.t union types *)
 | SpU_or : forall (A B:typ),
     splu (t_or A B) A B
 | SpU_andl : forall (A B A1 A2:typ),
     splu A A1 A2 ->
     splu (t_and A B) (t_and A1 B) (t_and A2 B)
 | SpU_andr : forall (A B B1 B2:typ),
     ordu A ->
     splu B B1 B2 ->
     splu (t_and A B) (t_and A B1) (t_and A B2).


(* This is algorithmic subtyping defined in Fig. 6 *)
Inductive singlemode_sub : typ -> typ -> Prop :=
 | SS_int :
     singlemode_sub t_int t_int
 | SS_top : forall (A:typ),
     singlemode_sub A t_top
 | SS_bot : forall (A:typ),
     singlemode_sub t_bot A
 | SS_arrow : forall (A1 A2 B1 B2:typ),
     single_ord (t_arrow A1 A2) ->
     single_ord (t_arrow B1 B2) ->
     singlemode_sub B1 A1 ->
     singlemode_sub A2 B2 ->
     singlemode_sub (t_arrow A1 A2) (t_arrow B1 B2)
 | SS_and : forall (A B B1 B2:typ),
     single_spl B B1 B2 ->
     singlemode_sub A B1 ->
     singlemode_sub A B2 ->
     singlemode_sub A B
 | SS_andl : forall (A B A1 A2:typ),
     single_ord B ->
     single_spl A A1 A2 ->
     singlemode_sub A1 B ->
     singlemode_sub A B
 | SS_andr : forall (A B A1 A2:typ),
     single_ord B ->
     single_spl A A1 A2 ->
     singlemode_sub A2 B ->
     singlemode_sub A B
 | SS_or : forall (A B A1 A2:typ),
     single_ord A ->
     single_ord B ->
     splu A A1 A2 ->
     singlemode_sub A1 B ->
     singlemode_sub A2 B ->
     singlemode_sub A B
 | SS_orl : forall (A B B1 B2:typ),
     single_ord A ->
     single_ord B ->
     ordu A ->
     splu B B1 B2 ->
     singlemode_sub A B1 ->
     singlemode_sub A B
 | SS_orr : forall (A B B1 B2:typ),
     single_ord A ->
     single_ord B ->
     ordu A ->
     splu B B1 B2 ->
     singlemode_sub A B2 ->
     singlemode_sub A B.


(* This is the declarative duotyping defined in Fig. 7 *)
Inductive osub : typ -> mode -> typ -> Prop :=
 | OS_refl : forall (A:typ) (mode5:mode),
     osub A mode5 A
 | OS_trans : forall (A:typ) (mode5:mode) (C B:typ),
     osub A mode5 B ->
     osub B mode5 C ->
     osub A mode5 C
 | OS_top : forall (A:typ) (mode5:mode),
     osub A mode5  (typbymode mode5 )
 | OS_arr : forall (A C:typ) (mode5:mode) (B D:typ),
     osub A  (flipmode  mode5 )  B ->
     osub C mode5 D ->
     osub (t_arrow A C) mode5 (t_arrow B D)
 | OS_and : forall (A:typ) (mode5:mode) (B C:typ),
     osub A mode5 B ->
     osub A mode5 C ->
     osub A mode5  (choose mode5 B C )
 | OS_andl : forall (A:typ) (mode5:mode) (B:typ),
     osub  (choose mode5 A B )  mode5 A
 | OS_andr : forall (A:typ) (mode5:mode) (B:typ),
     osub  (choose mode5 A B )  mode5 B
 | OS_distArr : forall (A B C:typ) (mode5:mode),
     osub (t_and  (t_arrow A B)   (t_arrow A C) ) mode5 (t_arrow A (t_and B C))
 | OS_distArrU : forall (A C B:typ) (mode5:mode),
     osub (t_and  (t_arrow A C)   (t_arrow B C) ) mode5 (t_arrow (t_or A B) C)
 | OS_distOr : forall (A1:typ) (mode5:mode) (B A2:typ),
     osub  (choose mode5  (choose  (flipmode  mode5 )  A1 B )   (choose  (flipmode  mode5 )  A2 B )  )  mode5  (choose  (flipmode  mode5 )   (choose mode5 A1 A2 )  B )
 | OS_flip : forall (A:typ) (mode5:mode) (B:typ),
     osub B  (flipmode  mode5 )  A ->
     osub A mode5 B.


(* This is the ordinary types defined in Fig. 8 *)
Inductive ord : mode -> typ -> Prop :=    (* parameterized by mode *)
 | O_top : forall (m:mode),
     ord m t_top
 | O_bot : forall (m:mode),
     ord m t_bot
 | O_int : forall (m:mode),
     ord m t_int
 | O_arrowUnion : forall (A B:typ),
     ord m_super (t_arrow A B)
 | O_arrow : forall (A B:typ),
     ord m_super A ->
     ord m_sub B ->
     ord m_sub (t_arrow A B)
 | O_or : forall (m:mode) (A B:typ),
     ord m A ->
     ord m B ->
     ord m  (choose  (flipmode  m )  A B ) .


(* This is the splittable types defined in Fig. 8 *)
Inductive spl : mode -> typ -> typ -> typ -> Prop := (* parameterized by mode *)
 | Sp_and : forall (m:mode) (A B:typ),
     spl m  (choose m A B )  A B
 | Sp_arrow : forall (A B C D:typ),
     spl m_sub B C D ->
     spl m_sub (t_arrow A B) (t_arrow A C) (t_arrow A D)
 | Sp_arrowUnion : forall (A D B C:typ),
     ord m_sub D ->
     spl m_super A B C ->
     spl m_sub (t_arrow A D) (t_arrow B D) (t_arrow C D)
 | Sp_orl : forall (m:mode) (A B A1 A2:typ),
     spl m A A1 A2 ->
     spl m  (choose  (flipmode  m )  A B )   (choose  (flipmode  m )  A1 B )   (choose  (flipmode  m )  A2 B )
 | Sp_orr : forall (m:mode) (A B B1 B2:typ),
     ord m A ->
     spl m B B1 B2 ->
     spl m  (choose  (flipmode  m )  A B )   (choose  (flipmode  m )  A B1 )   (choose  (flipmode  m )  A B2 ) .


(* This is the algorithmic duotyping defined in Fig. 8 *)
Inductive duo : typ -> mode -> typ -> Prop :=
 | SD_int : forall (mode5:mode),
     duo t_int mode5 t_int
 | SD_top : forall (A:typ) (mode5:mode),
     duo A mode5  (typbymode mode5 )
 | SD_and : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     spl mode5 B B1 B2 ->
     duo A mode5 B1 ->
     duo A mode5 B2 ->
     duo A mode5 B
 | SD_andl : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     ord mode5 B ->
     spl mode5 A A1 A2 ->
     duo A1 mode5 B ->
     duo A mode5 B
 | SD_andr : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     ord mode5 B ->
     spl mode5 A A1 A2 ->
     duo A2 mode5 B ->
     duo A mode5 B
 | SD_dual : forall (A:typ) (mode5:mode) (B:typ),
     ord mode5 A ->
     ord mode5 B ->
     duo B  (flipmode  mode5 )  A ->
     duo A mode5 B
 | SD_arr : forall (A1 A2:typ) (mode5:mode) (B1 B2:typ),
     ord m_sub (t_arrow A1 A2) ->
     ord m_sub (t_arrow B1 B2) ->
     duo A1  (flipmode  mode5 )  B1 ->
     duo A2 mode5 B2 ->
     duo (t_arrow A1 A2) mode5 (t_arrow B1 B2).

(* This is the algorithmic duotyping with no dual rule D-dual.
   Some rules come with its dual *)
Inductive sub : typ -> mode -> typ -> Prop :=
 | S_int : forall (mode5:mode),
     sub t_int mode5 t_int
 | S_top : forall (A:typ) (mode5:mode),
     sub A mode5  (typbymode mode5 )
 | S_bot : forall (mode5:mode) (A:typ),
     sub  (typbymode  (flipmode  mode5 )  )  mode5 A
 | S_arr : forall (A1 A2:typ) (mode5:mode) (B1 B2:typ),
     ord m_sub (t_arrow A1 A2) ->
     ord m_sub (t_arrow B1 B2) ->
     sub A1  (flipmode  mode5 )  B1 ->
     sub A2 mode5 B2 ->
     sub (t_arrow A1 A2) mode5 (t_arrow B1 B2)
 | S_and : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     spl mode5 B B1 B2 ->
     sub A mode5 B1 ->
     sub A mode5 B2 ->
     sub A mode5 B
 | S_andl : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     ord mode5 B ->
     spl mode5 A A1 A2 ->
     sub A1 mode5 B ->
     sub A mode5 B
 | S_andr : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     ord mode5 B ->
     spl mode5 A A1 A2 ->
     sub A2 mode5 B ->
     sub A mode5 B
 | S_or : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     ord mode5 A ->
     ord mode5 B ->
     spl  (flipmode  mode5 )  A A1 A2 ->
     sub A1 mode5 B ->
     sub A2 mode5 B ->
     sub A mode5 B
 | S_orl : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     ord mode5 A ->
     ord mode5 B ->
     ord  (flipmode  mode5 )  A ->
     spl  (flipmode  mode5 )  B B1 B2 ->
     sub A mode5 B1 ->
     sub A mode5 B
 | S_orr : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     ord mode5 A ->
     ord mode5 B ->
     ord  (flipmode  mode5 )  A ->
     spl  (flipmode  mode5 )  B B1 B2 ->
     sub A mode5 B2 ->
     sub A mode5 B.


(* This is the algorithmic duotyping with no dual rule D-dual and
   no ordinary-type condition *)
Inductive lsub : typ -> mode -> typ -> Prop :=
 | LS_int : forall (mode5:mode),
     lsub t_int mode5 t_int
 | LS_top : forall (A:typ) (mode5:mode),
     lsub A mode5  (typbymode mode5 )
 | LS_bot : forall (mode5:mode) (A:typ),
     lsub  (typbymode  (flipmode  mode5 )  )  mode5 A
 | LS_arr : forall (A1 A2:typ) (mode5:mode) (B1 B2:typ),
     lsub A1  (flipmode  mode5 )  B1 ->
     lsub A2 mode5 B2 ->
     lsub (t_arrow A1 A2) mode5 (t_arrow B1 B2)
 | LS_and : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     spl mode5 B B1 B2 ->
     lsub A mode5 B1 ->
     lsub A mode5 B2 ->
     lsub A mode5 B
 | LS_andl : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     spl mode5 A A1 A2 ->
     lsub A1 mode5 B ->
     lsub A mode5 B
 | LS_andr : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     spl mode5 A A1 A2 ->
     lsub A2 mode5 B ->
     lsub A mode5 B
 | LS_or : forall (A:typ) (mode5:mode) (B A1 A2:typ),
     spl  (flipmode  mode5 )  A A1 A2 ->
     lsub A1 mode5 B ->
     lsub A2 mode5 B ->
     lsub A mode5 B
 | LS_orl : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     spl  (flipmode  mode5 )  B B1 B2 ->
     lsub A mode5 B1 ->
     lsub A mode5 B
 | LS_orr : forall (A:typ) (mode5:mode) (B B1 B2:typ),
     spl  (flipmode  mode5 )  B B1 B2 ->
     lsub A mode5 B2 ->
     lsub A mode5 B.
