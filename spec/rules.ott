%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

typ, A, B, C, D, char {{ tex \mathsf{Char} }}, bool {{ tex \mathsf{Bool} }} % , ll {{ tex \{ l \} }}
  :: 't_'             ::=                  {{ com types }}
  | int               ::   :: int          {{ com int }} {{ tex \mathsf{Int} }}
  | Top               ::   :: top          {{ com top type }} {{ tex \mathsf{Top} }}
  | Bot               ::   :: bot          {{ com bottom type }} {{ tex \mathsf{Bot} }}
  | A -> B            ::   :: arrow        {{ com function types }}
  | A /\ B            ::   :: and          {{ com intersection }}
  | A \/ B            ::   :: or           {{ com union }}
  | ( A )             :: S :: paren        {{ coq [[A]] }}
%  | { l : A }         ::   :: rcd          {{ com record }}
  | | mode |          :: S :: topbot       {{ coq (typbymode[[mode]]) }}
  | [ A mode B ]      :: S :: choose       {{ coq (choose[[mode]][[A]][[B]]) }}


mode {{ tex \Diamond }}, m {{ tex \Diamond }}
  :: 'm_'             ::=
  | sub               ::   :: sub          {{ tex < }}
  | super             ::   :: super        {{ tex > }}
  | ! mode            :: S :: flip         {{ tex \overline{[[mode]]} }} {{ coq (flipmode [[mode]]) }}

parsing
  t_or <= t_and
  t_arrow <= t_or
  t_arrow <= t_and
  t_arrow right t_arrow
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar


terminals :: 'terminals_' ::=
  | ->               ::  :: arrow      {{ tex \rightarrow }}
  | /\                ::  :: and        {{ tex \, \/\ \, }}
  | \/               ::  :: or         {{ tex \, \mid \, }}
  | ,                ::  :: break      {{ tex , }}
  | <:b              ::  :: subb       {{ tex <: }}
  | <::              ::  :: subd       {{ tex <: }}
  | ||-              ::  :: turnstileb {{ tex \vdash }}
  | <|               ::  :: triangleL  {{ tex \mathbin{\lhd} }}
  | |>               ::  :: triangleR  {{ tex \mathbin{\rhd} }}


formula :: 'formula_' ::=
  | judgement        ::   :: judgement
  | not formula      :: M :: not
    {{ tex \neg [[formula]] }}
    {{ coq not ([[formula]]) }}
  | ( formula )      :: M :: brackets
    {{ tex ([[formula]]\!) }}
    {{ coq [[formula]] }}
  | < formula >              :: M :: high_form
    {{ tex \hlmath{[[formula]]} }}
    {{ coq [[formula]] }}
  | l1 <> l2                 ::   :: label
    {{ coq [[l1]] <> [[l2]] }}
    {{ tex [[l1]] \neq [[l2]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

embed
{{ coq

Definition typbymode (m: mode) :=
  match m with
  | m_sub => t_top
  | m_super => t_bot
  end.

Definition choose (m: mode) (A: typ) (B: typ) :=
  match m with
  | m_sub => t_and A B
  | m_super => t_or A B
  end.

Definition flipmode (m: mode) :=
  match m with
  | m_sub => m_super
  | m_super => m_sub
  end.

}}


%%%%%%%%%%%%%%%%%%%
% Subtyping rules %
%%%%%%%%%%%%%%%%%%%


defns
DSub :: '' ::=

defn
A < B  :: :: declarative_subtyping :: DS_
{{ com Declarative Subtyping }}
{{ tex [[A]] \leq [[B]] }}
by


---------------------- :: refl
A < A


A < B
B < C
--------------- :: trans
A < C


--------------- :: top
A < Top


--------------- :: bot
Bot < A


B < A
C < D
------------------------ :: arrow
A -> C < B -> D


A < B
A < C
--------------- :: and
A < B /\ C


------------------------- :: andl
A /\ B < A


----------------- :: andr
A /\ B < B


A < C
B < C
--------------- :: or
A \/ B < C


------------------------- :: orl
A < A \/ B


----------------- :: orr
B < A \/ B


-------------------------------------- :: distOr
(A1 \/ B) /\ (A2 \/ B) < (A1 /\ A2) \/ B


% omittable
-------------------------------------- :: distAnd
(A1 \/ A2) /\ B < (A1 /\ B) \/ (A2 /\ B)


---------------------------------------------------- :: distArrI
(A1 -> B1) /\ (A2 -> B2) < (A1 \/ A2) -> (B1 /\ B2)


---------------------------------------------------- :: distArrU
(A1 /\ A2) -> (B1 \/ B2) < (A1 -> B1) \/ (A2 -> B2)


%%%%%%%%%%%%%%%%%%%%%%
%Algorithmic Subtyping
%%%%%%%%%%%%%%%%%%%%%%

defns
Ordinary :: '' ::=

defn
ordinary A :: :: ordi :: OI_
{{ com ordinary types w.r.t. intersection types}}
{{ tex [[A]]~\mathsf{Ordinary} }}
by


---------------- :: top
ordinary Top


---------------- :: bot
ordinary Bot


---------------- :: int
ordinary int


ordinaryU A
ordinary B
---------------- :: arrow
ordinary A->B


ordinary A
ordinary B
---------------- :: or
ordinary A\/B


%ordinary B
%---------------- :: rcd
%ordinary {l:B}


defn
ordinaryU A :: :: ordu :: OU_
{{ com ordinary types w.r.t unions }}
{{ tex [[A]]~\mathsf{OrdinaryU} }}
by


---------------- :: top
ordinaryU Top


---------------- :: bot
ordinaryU Bot


---------------- :: int
ordinaryU int


ordinary A
ordinaryU B
---------------- :: arrow
ordinaryU A->B


ordinaryU A
ordinaryU B
---------------- :: and
ordinaryU A/\B



defns
Split :: '' ::=

defn
split A B C :: :: spli :: SpI_
{{ com Splittable Types w.r.t intersections }}
{{ tex [[B]] \mathbin{\lhd} [[A]] \mathbin{\rhd} [[C]] }}
by


----------------:: and
split A/\B A B


split A A1 A2
-------------------------- :: orl
split A\/B A1\/B A2\/B


ordinary A
split B B1 B2
-------------------------- :: orr
split A\/B A\/B1 A\/B2


splitU A A1 A2
split B B1 B2
-------------------------- :: arrow
split A->B A1->B1 A2->B2


ordinaryU A
split B B1 B2
-------------------------- :: arrowI
split A->B A->B1 A->B2


ordinary B
splitU A A1 A2
-------------------------- :: arrowU
split A->B A1->B A2->B


%split B C D
%-------------------------- :: rcd
%split {l:B} {l:C} {l:D}



defn
splitU A B C :: :: splu :: SpU_
{{ com Split Union Types }}
{{ tex [[B]] \mathbin{\LHD} [[A]] \mathbin{\RHD} [[C]] }}
by


--------------------:: or
splitU A\/B A B


splitU A A1 A2
-------------------------- :: andl
splitU A/\B A1/\B A2/\B


ordinaryU A
splitU B B1 B2
-------------------------- :: andr
splitU A/\B A/\B1 A/\B2


split A A1 A2
splitU B B1 B2
--------------------------- :: arrow
splitU A->B A1->B1 A2->B2


ordinary A
splitU B B1 B2
-------------------------- :: arrowI
splitU A->B A->B1 A->B2


ordinaryU B
split A A1 A2
-------------------------- :: arrowU
splitU A->B A1->B A2->B


%splitU B C D
%-------------------------- :: rcd
%splitU {l:B} {l:C} {l:D}



defns
ASub :: '' ::=

defn
A <: B  :: :: algorithmic_sub :: AS_
{{ com Algorithmic Subtyping }}
by


---------------------- :: int
int <: int


---------------------- :: top
A <: Top


---------------------- :: bot
Bot <:  A


B1 <: A1
A2 <: B2
------------------------ :: arrow
A1 -> A2 <: B1 -> B2


split B B1 B2
A <: B1
A <: B2
--------------- :: and
A <: B


split A A1 A2
A1 <: B
------------------------- :: andl
A <: B


split A A1 A2
A2 <: B
------------------------- :: andr
A <: B


splitU A A1 A2
A1 <: B
A2 <: B
--------------- :: or
A <: B  


splitU B B1 B2
A <: B1
------------------------- :: orl
A <: B


splitU B B1 B2
A <: B2
------------------------- :: orr
A <: B
