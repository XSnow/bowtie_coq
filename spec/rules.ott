%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar typevar, X , Y ::= {{ repr-locally-nameless }}
  
indexvar I, J, h, i, j, n, m ::= {{ coq nat }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar
l, k :: 'lbl_' ::=
  | i ::  :: TagIndex
  | tleft :: :: TagLeft {{ tex \mathrm{left} }}
  | tright :: :: TagRight {{ tex \mathrm{right} }}
  

A , B , C :: 't_' ::= {{ com value type }}
  | X                                ::  :: tvar
  | In l A                           ::  :: rcd      {{ tex \tytag{[[l]]}{[[A]]} }}
  | A1 &  A2                         ::  :: and
  | A1 |  A2                         ::  :: or
  | A -> B                           ::  :: arrow
  | forall X . B                     ::  :: forall   (+ bind X in B +)
  | Top                              ::  :: top
  | Empty                            ::  :: bot

  | Tcov [ A ]                       :: M:: ctx      {{ icho (appctx_Tcov [[Tcov]] [[A]]) }}
  | ( A )                            :: S:: paren    {{ icho [[A]] }}
  | A [ X ~> B ]                     :: M:: tsubst   {{ coq (open_typ_wrt_typ [[X]][[A]][[B]]) }}


Tcov {{ tex \tau }} :: 'ty_ctx_cov' ::= {{ com covariant type context }}
  | In l [-]            :: :: TcovIn   {{ tex \tytag{[[l]]}{\hole} }}
  | A -> [-]            :: :: TcovArr
  | forall [-]          :: :: TcovAll
  | [-] & A             :: :: TCovInterL
  | A & [-]             :: :: TCovInterR
  | [-] | A             :: :: TCovUnionL
  | A | [-]             :: :: TCovUnionR

terminals :: 'terminals_' ::=
  | [-]          ::    :: hole      {{ tex \hole }}
  | &            ::    :: intersect {{ tex \sqcap }}
  | |            ::    :: union     {{ tex \sqcup }}
  | forall       ::    :: forall    {{ tex \forall }}
  | exists       ::    :: exists    {{ tex \exists }}
  | nil          ::    :: nil       {{ tex \kw{*} }}
  | notin        ::    :: notin     {{ tex \notin }}
  | Top          ::    :: topty     {{ tex \tytop }}
  | Empty        ::    :: emptyty   {{ tex \tyempty }}

formula :: formula_ ::=  
   | judgement                       ::   :: judgement
   | l != l'                         ::   :: labNeq
   | l = l'                          ::   :: labEq
   | ( formula )                     ::   :: formulaParen

%contextrules
%  Tcov _:: A :: A


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
embed
{{ coq
(** context application *)
Definition appctx_Tcov (Tcov5:Tcov) (A_6:A) : A :=
  match Tcov5 with
  | (ty_ctx_covTcovIn l5) => (t_rcd l5 A_6)
  | (ty_ctx_covTcovArr A5) => (t_arrow A5 A_6)
  | (ty_ctx_covTcovAll) => (t_forall A_6)
  | (ty_ctx_covTCovInterL A5) => (t_and A_6 A5)
  | (ty_ctx_covTCovInterR A5) => (t_and A5 A_6)
  | (ty_ctx_covTCovUnionL A5) => (t_or A_6 A5)
  | (ty_ctx_covTCovUnionR A5) => (t_or A5 A_6)
end.
}}

defns
DSub :: '' ::=

  defn
  A <: B
  :: :: DeclarativeSubtyping :: ''
  {{ com Declarative subtyping }}
  by


  ----------- :: DSubRefl
  A <: A

  A1 <: A2
  A2 <: A3
  ------------- :: DSubTrans
  A1 <: A3

  A <: B
  -------------------- :: DSubCov 
  Tcov [ A ] <: Tcov [ B ]

  A2 <: A1
  -------------------- :: DSubFunCon
  A1 -> B <: A2 -> B

  -------------------------------- :: DSubCovDistI 
  Tcov[A] & Tcov[B] <: Tcov[A & B]

  ------------------------------------------------- :: DSubFunDistU
  (A1 & A2) -> (B1 | B2) <: (A1 -> B1) | (A2 -> B2)

  ------------------------------------------------- :: DSubFunDistI
  (A1 -> B) & (A2 -> B) <: (A1 | A2) -> B 


  ---------- :: DSubEmpty
  Empty <: B

  --------- :: DSubTop
  A <: Top


% I think these are derivable from the above

  % --------------------------------------- :: DSubUnionDistI 
  % A1 & (A2 | A3) <: (A1 & A2) | (A1 & A3)

  % --------------------------------------- :: DSubInterDistU
  % A1 | (A2 & A3) <: (A1 | A2) & (A1 | A3)

  A1 <: B
  ----------------- :: DSubInterLL
  A1 & A2 <: B

  A2 <: B
  ----------------- :: DSubInterLR
  A1 & A2 <: B

  A <: B1
  A <: B2
  ----------------- :: DSubInterR
  A <: B1 & B2

  A1 <: B
  A2 <: B
  ------------ :: DSubUnionL
  A1 | A2 <: B

  A <: B1
  ------------ :: DSubUnionRL
  A <: B1 | B2

defns
Ordinary :: '' ::=

  defn ordinaryU A :: :: UnionOrdinary :: OrdU_
  by

  ------------- :: top
  ordinaryU Top

  --------------- :: bot
  ordinaryU Empty

  ---------------- :: arrow
  ordinaryU A -> B

  ordinaryU A
  ordinaryU B
  --------------- :: and
  ordinaryU A & B

  ordinaryU A
  ---------------- :: rcd
  ordinaryU In l A

  ordinaryU A
  ---------------------- :: forall
  ordinaryU forall X . A


  defn ordinaryI A :: :: IntersectionOrdinary :: OrdI_
  by

  ------------- :: top
  ordinaryI Top

  --------------- :: bot
  ordinaryI Empty

  ordinaryU A
  ordinaryI B
  ---------------- :: arrow
  ordinaryI A -> B

  ordinaryI A
  ordinaryI B
  --------------- :: or
  ordinaryI A | B

  ordinaryI A
  ---------------- :: rcd
  ordinaryI In l A

  ordinaryI A
  ---------------------- :: forall
  ordinaryI forall X . A


  defn splitI A = B1 & B2 :: :: SplitIntersection :: ''
  by

  -------------------- :: SpIIntersection
  splitI A & B = A & B

  splitI A = A1 & A2
  ---------------------------------- :: SpIUnionL
  splitI A | B = A1 | B & A2 | B

  splitI B = B1 & B2
  ---------------------------------- :: SpIUnionR
  splitI A | B = A | B1 & A | B2

  splitI B = B1 & B2
  --------------------------------- :: SpIFunR
  splitI A -> B = A -> B1 & A -> B2

  splitU A = A1 | A2
  --------------------------------- :: SpIFunL
  splitI A -> B = A1 -> B & A2 -> B

  splitI A = A1 & A2
  --------------------------------------------------- :: SpIFunTy
  splitI forall X . A = forall X . A1 & forall X . A2

  splitI A = A1 & A2 
  --------------------------------- :: SpIIn
  splitI In l A = In l A1 & In l A2


  defn splitU A = B1 | B2 :: :: SplitUnion :: ''
  by

  -------------------- :: SpUUnion
  splitU A | B = A | B

  splitU A = A1 | A2
  ------------------------------ :: SpUIntersectionL
  splitU A & B = A1 & B | A2 & B

  splitU B = B1 | B2
  ------------------------------ :: SpUIntersectionR
  splitU A & B = A & B1 | A & B2

  splitU B = B1 | B2
  --------------------------------- :: SpUFunR
  splitU A -> B = A -> B1 | A -> B2

  splitI A = A1 & A2
  --------------------------------- :: SpUFunL
  splitU A -> B = A1 -> B | A2 -> B

  splitU A = A1 | A2
  --------------------------------------------------- :: SpUFunTy
  splitU forall X . A = forall X . A1 | forall X . A2

  splitU A = A1 | A2 
  --------------------------------- :: SpUIn
  splitU In l A = In l A1 | In l A2
