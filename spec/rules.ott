%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar typevar, X , Y ::= {{ repr-locally-nameless }}
  
metavar I, J, h, i, j, n, m ::= {{ coq nat }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
grammar

l, k :: 'lbl_' ::=
  | i ::  :: TagIndex
  | tleft :: :: TagLeft {{ tex \mathrm{left} }}
  | tright :: :: TagRight {{ tex \mathrm{right} }}
  

typ, A , B , C :: 't_' ::= {{ com value type }}
  | X                                ::  :: tvar
  | In l A                           ::  :: rcd      {{ tex \tytag{[[l]]}{[[A]]} }}
  | A1 & A2                          ::  :: and
  | A1 | A2                          ::  :: or
  | A -> B                           ::  :: arrow
  | forall X . B                     ::  :: forall   (+ bind X in B +)
  | Top                              ::  :: top
  | Empty                            ::  :: bot

%   | Tcov [ A ]                       :: M:: ctx      {{ icho (appctx_Tcov [[Tcov]] [[A]]) }}
  | ( A )                            :: S:: paren    {{ icho [[A]] }}
  | A [ X ~> B ]                     :: M:: tsubst   {{ coq (open_typ_wrt_typ [[X]][[A]][[B]]) }}


% Tcov {{ tex \tau }} :: 'ty_ctx_cov' ::= {{ com covariant type context }}
%   | In l [-]            :: :: TcovIn   {{ tex \tytag{[[l]]}{\hole} }}
%   | A -> [-]            :: :: TcovArr
%   | forall [-]          :: :: TcovAll
%   | [-] & A             :: :: TCovInterL
%   | A & [-]             :: :: TCovInterR
%   | [-] | A             :: :: TCovUnionL
%   | A | [-]             :: :: TCovUnionR

terminals :: 'terminals_' ::=
  | [-]          ::    :: hole      {{ tex \hole }}
  | &            ::    :: intersect {{ tex \sqcap }}
  | |            ::    :: union     {{ tex \sqcup }}
  | forall       ::    :: forall    {{ tex \forall }}
  | exists       ::    :: exists    {{ tex \exists }}
  | nil          ::    :: nil       {{ tex \kw{*} }}
  | notin        ::    :: notin     {{ tex \notin }}
  | Top          ::    :: topty     {{ tex \tytop }}
  | Empty        ::    :: emptyty   {{ tex \tyempty }}
  | <a           ::    :: algosub   {{ tex <_a }}

formula :: formula_ ::=  
   | judgement                       ::   :: judgement
   | l != l'                         ::   :: labNeq
   | l = l'                          ::   :: labEq
   | ( formula )                     ::   :: formulaParen

%contextrules
%  Tcov _:: typ :: typ

substitutions
  single typ X   :: typsubst

freevars
  typ X      :: typefv
  
parsing
  t_arrow <= t_and
  t_forall <= t_and
  t_arrow <= t_or
  t_forall <= t_or
  t_arrow right t_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% embed
% {{ coq
% (** context application *)
% Definition appctx_Tcov (Tcov5:Tcov) (A_6:A) : A :=
%   match Tcov5 with
%   | (ty_ctx_covTcovIn l5) => (t_rcd l5 A_6)
%   | (ty_ctx_covTcovArr A5) => (t_arrow A5 A_6)
%   | (ty_ctx_covTcovAll) => (t_forall A_6)
%   | (ty_ctx_covTCovInterL A5) => (t_and A_6 A5)
%   | (ty_ctx_covTCovInterR A5) => (t_and A5 A_6)
%   | (ty_ctx_covTCovUnionL A5) => (t_or A_6 A5)
%   | (ty_ctx_covTCovUnionR A5) => (t_or A5 A_6)
% end.
% }}


defns
DSub :: '' ::=

  defn
  A <: B
  :: :: DeclarativeSubtyping :: DSub_
  {{ com Declarative subtyping }}
  by


  ----------- :: Refl
  A <: A

  A1 <: A2
  A2 <: A3
  ------------- :: Trans
  A1 <: A3



  A <: B
  -------------------- :: CovIn
  In l A <: In l B
  
  A <: B
  -------------------- :: CovArr
  C -> A <: C -> B
  
  A <: B
  --------------------------- :: CovAll
  forall X. A <: forall X. B
  
  A <: B
  -------------------- :: CovInterL
  A & C <: B & C
  
  A <: B
  -------------------- :: CovInterR
  C & A <: C & B

  A <: B
  -------------------- :: CovUnionL
  A | C <: B | C
  
  A <: B
  -------------------- :: CovUnionR
  C | A <: C | B



  A2 <: A1
  -------------------- :: FunCon
  A1 -> B <: A2 -> B



  ------------------------------------- :: CovDistIIn
  (In l A) & (In l B) <: In l (A & B)
  
  ------------------------------------- :: CovDistIArr
  (C -> A) & (C -> B) <: (C -> A & B)
  

  % ------------------------------------- :: CovDistIInterL
  %  (A & C) & (B & C) <: (A & B) & C
   
  % ------------------------------------- :: CovDistIInterR
  %  (C & A) & (C & B) <: C & (A & B)
  
  ------------------------------------- :: CovDistIUnionL
  (A | C) & (B | C) <: (A & B) | C
  
  ------------------------------------- :: CovDistIUnionR
  (C | A) & (C | B) <: C | (A & B)

  ------------------------------------------------------ :: CovDistIAll
  (forall X. A) & (forall X. B) <: (forall X. A & B)  


% I omit these two (and two in the following CovDistU set of rules) since they are trivially admissible

  ------------------------------------- :: CovDistUIn
  In l (A | B) <: (In l A) | (In l B)
  
  ------------------------------------------------------ :: CovDistUAll
  forall X. (A | B) <: (forall X. A) | (forall X. B)

  ------------------------------------- :: CovDistUInterL
  (A | B) & C <: (A & C) | (B & C)
   
  ------------------------------------- :: CovDistUInterR
  C & (A | B) <: (C & A) | (C & B)



  ------------------------------------------------- :: FunDistI
  (A1 -> B) & (A2 -> B) <: (A1 | A2) -> B 


% I think these are derivable from the above

  % --------------------------------------- :: UnionDistI 
  % A1 & (A2 | A3) <: (A1 & A2) | (A1 & A3)

  % --------------------------------------- :: InterDistU
  % A1 | (A2 & A3) <: (A1 | A2) & (A1 | A3)


  A1 <: B
  ----------------- :: InterLL
  A1 & A2 <: B

  A2 <: B
  ----------------- :: InterLR
  A1 & A2 <: B

  A <: B1
  A <: B2
  ----------------- :: InterR
  A <: B1 & B2

  A1 <: B
  A2 <: B
  ------------ :: UnionL
  A1 | A2 <: B

  A <: B1
  ------------ :: UnionRL
  A <: B1 | B2

  A <: B2
  ------------ :: UnionRR
  A <: B1 | B2
  
  ---------- :: Empty
  Empty <: B

  --------- :: Top
  A <: Top


defns
Ordinary :: '' ::=

  defn ordinaryU A :: :: ordu :: OrdU_
  by

  ------------- :: var
  ordinaryU X
  
  ------------- :: top
  ordinaryU Top

  --------------- :: bot
  ordinaryU Empty

  ---------------- :: arrow
  ordinaryU A -> B

  ordinaryU A
  ordinaryU B
  --------------- :: and
  ordinaryU A & B

  ordinaryU A
  ---------------- :: rcd
  ordinaryU In l A

  ordinaryU A
  ---------------------- :: forall
  ordinaryU forall X . A


  defn ordinaryI A :: :: ordi :: OrdI_
  by

  ------------- :: var
  ordinaryI X

  ------------- :: top
  ordinaryI Top

  --------------- :: bot
  ordinaryI Empty

  ordinaryU A
  ordinaryI B
  ---------------- :: arrow
  ordinaryI A -> B

  ordinaryI A
  ordinaryI B
  --------------- :: or
  ordinaryI A | B

  ordinaryI A
  ---------------- :: rcd
  ordinaryI In l A

  ordinaryI A
  ---------------------- :: forall
  ordinaryI forall X . A


defns
Split :: '' ::=

  defn splitI A = B1 & B2 :: :: spli :: SpI_
  by

  -------------------- :: and
  splitI A & B = A & B

  splitI A = A1 & A2
  ---------------------------------- :: orl
  splitI A | B = A1 | B & A2 | B

  splitI B = B1 & B2
  ---------------------------------- :: orr
  splitI A | B = A | B1 & A | B2

  splitI B = B1 & B2
  --------------------------------- :: arrow
  splitI A -> B = A -> B1 & A -> B2

  ordinaryI B
  splitU A = A1 | A2
  --------------------------------- :: arrowUnion
  splitI A -> B = A1 -> B & A2 -> B

  splitI A = A1 & A2
  --------------------------------------------------- :: forall
  splitI forall X . A = forall X . A1 & forall X . A2

  splitI A = A1 & A2 
  --------------------------------- :: in
  splitI In l A = In l A1 & In l A2


  defn splitU A = B1 | B2 :: :: splu :: SpU_
  by

  -------------------- :: or
  splitU A | B = A | B

  splitU A = A1 | A2
  ------------------------------ :: andl
  splitU A & B = A1 & B | A2 & B

  splitU B = B1 | B2
  ------------------------------ :: andr
  splitU A & B = A & B1 | A & B2

%  splitU B = B1 | B2
%  --------------------------------- :: SpUFunR
%  splitU A -> B = A -> B1 | A -> B2
%
%  splitI A = A1 & A2
%  --------------------------------- :: SpUFunL
%  splitU A -> B = A1 -> B | A2 -> B
%
  splitU A = A1 | A2
  --------------------------------------------------- :: forall
  splitU forall X . A = forall X . A1 | forall X . A2

  splitU A = A1 | A2 
  --------------------------------- :: in
  splitU In l A = In l A1 | In l A2


defns
AlgorithmicSubtyping :: '' ::=

  defn
  A <a B  :: :: algo_sub :: ASub_
  {{ com Algorithmic Subtyping }}
  by
  
  
  ---------------------- :: var
  X <a X
  
  ---------------------- :: top
  A <a Top
  
  ---------------------- :: bot
  Empty <a  A
  
  B1 <a A1
  A2 <a B2
  ------------------------ :: arrow
  A1 -> A2 <a B1 -> B2
  
  splitI B = B1 & B2
  A <a B1
  A <a B2
  --------------- :: and
  A <a B
  
  splitI A = A1 & A2
  A1 <a B
  ------------------------- :: andl
  A <a B
  
  splitI A = A1 & A2
  A2 <a B
  ------------------------- :: andr
  A <a B
  
  splitU A = A1 | A2
  A1 <a B
  A2 <a B
  --------------- :: or
  A <a B  
  
  splitU B = B1 | B2
  A <a B1
  ------------------------- :: orl
  A <a B
  
  splitU B = B1 | B2
  A <a B2
  ------------------------- :: orr
  A <a B
