Challenge: A & ( B | C ) <: ( A & B ) | ( A & C )
Workaround: forbid union and intersection to be nested.
* omit record types

--------------------------------------------------------------

TypeWellformedness

OrdinaryType            T ::= Int | Top | Bot | T1 -> T2
IntersectionType        I ::= T | I1 & I2
UnionType               U ::= T | U1  \/ U2
CompoundType            A ::= I | U | A1 -> A2

--------------------------------------------------------------

defns
SplitType :: '' ::=

defn
split A B C :: :: spl :: Sp_
{{ com Splittable Types }}
{{ tex [[B]] \mathbin{\lhd} [[A]] \mathbin{\rhd} [[C]] }}
by


----------------:: and
split A&B A B


split B C D
-------------------------- :: arrow
split A->B A->C A->D


split B C D
-------------------------- :: rcd
split {l:B} {l:C} {l:D}


splitU A B C
-------------------------- :: arrowUnion
split A->D B->D C->D



defns
SplitUnionType :: '' ::=

defn
splitU A B C :: :: splu :: SpU_
{{ com Split Union Types }}
{{ tex [[B]] \mathbin{\LHD} [[A]] \mathbin{\RHD} [[C]] }}
by


-------------------:: and
splitU A or B A B


splitU B C D
-------------------------- :: arrow
splitU A->B A->C A->D


splitU B C D
-------------------------- :: rcd
splitU {l:B} {l:C} {l:D}


split A B C
-------------------------- :: arrowUnion
splitU A->D B->D C->D



defns
Subtyping_bcd :: '' ::=

defn
A <:b B  :: :: sub_bcd :: S_bcd_
{{ com Modular BCD Subtyping  (\textless :)}}
by


---------------------- :: int
int <:b int


< ordinary_bcd B >
topLike B
--------------- :: top
A <:b B


< ordinary_bcd C >
A <:b C
------------------------- :: andl
A & B <:b C


< ordinary_bcd C >
B <:b C
----------------- :: andr
A & B <:b C


< ordinary_bcd D >
B <:b A
C <:b D
------------------------ :: arr
A -> C <:b B -> D


< ordinary_bcd D >
C <:b D
------------------------ :: rcd
{l:C} <:b {l:D}


split D B C
A <:b B
A <:b C
--------------- :: and
A <:b D
